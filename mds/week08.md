## 목표

자바의 인터페이스에 대해 학습하세요.

## 학습할 것 (필수)

- 인터페이스 정의하는 방법
- 인터페이스 구현하는 방법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속
- 인터페이스의 기본 메소듣 (Default Method), 자바8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9


마감일시

2021년 1월 9일 토요일 오후 1시까지.

# 인터페이스 정의하는 방법

인터페이스란 객체와 객체  사이에서 일어나는 상호 작용의 매개로 쓰인다. 

모든 기능을 추상화로 정의한 상태로 선언한다.

인터페이스의 선언은 예약어로 class 대신 'interface' 키워드 사용한다.

접근 제어자로 public, default를 사용한다.

```java
interface InterfaceName
{
}
```

`implements` 키워드를 통해 일반 클래스에서 인터페이스를 구현할 수 있다.

Java 8 이전까지는 상수와 추상 멤서드만 선언가능했지만, Java 8 이후부터는 default method와 static method가 추가되었다.

```java
public interface 인터페이스 명 {
//상수
타입 상수명 = 값;

// 추상 메소드
타입 메소드명 (매개변수, ...);

// 디폴트 메소드
default 타입 메소드명 (매개변수, ...){
// 구현부
}

// 정적 메소드
stataic 타입 메소드명 (매개변수, ...) {
// 구현부
	}
}
```

1. 상수 . 고정
   1. 인터페이스에서 값을 고정해주고 함부로 바꾸지 못함, 제공하는 값만 참조하라.
2. 추상 메소드 (강제)
   1. 가이드만 주고 오버라이딩해서 재구현하시오.
3. 디폴트 메소드 (선택)
   1. 인터페이스에서 기본적으로 제공하지만, 구현내용을 원하지 않으면 오버라이딩해서 재구현 하시오
4. 스테틱 매소드 (절대)
   1. 인터페이스에서 제공하는 것으로 무조건 사용.

---

인터페이스는 추상 클래스처럼 인스턴스를 생성할 수 없고, 상속받은 클래스에서 구현한 뒤 자기 클래스를 인스턴스화해 사용한다.

### 추상클래스와 인터페이스의 차이

1. 추상 클래스는 일반 메서드와 추상 메서드 둘 다 가질 수 있다.
   1. 인터페이스는 오로지 추상 매서드와 상수만을 가질 수 있다.
2. 인터페이스 내에 존재하는 매서드는 무조건 " public abstract"로 선언되며, 이를 생략할 수 있다.
3. 인터페이스 내에 존재하는 변수는 무조건 "public static final"로 선언되며, 이를 생략.가능

#### 인터페이스 사용의 이유

1. 개발 기간 단축 가능
   1. 인터페이스를 이용하면 서로 규약만 정해두고 각자의 부분만 따로 작성한 코드를 컴파일 할 수 있다.
2. 클래스간 결합도를 낮출 수 있다.
   1. 코드 종속성을 낮추고 유지보수성을 높이도록 도와줌.
3. 표준화가 가능
   1. 클래스의 기본틀을 제공, 개발자들에게 정형화된 개발 가능
   2. 자바의 다형성을 극대화하여 코드의 수정을 줄이고 유지 보수성 높임.



---

- ## 인터페이스 구현하는 방법

#### 구현 클래스

보통의 클래스와 동일.

인터페이스 타입 알려주기 위해 클래스 선언부에 implements 키워드를 추가한다.

코드가 인터페이스 매소드를 호출하면 인터페이스는 객채의 매소드를 호출한다.

객체는 인터페이스에서 정의한 추상 매소드와 동일한 매소드 이름, 매개 타입, 리턴타입을 가진 매소드를 가지고 있어야 한다.

이러한 객체를 인터페이스의 구현(implements) 객채라고 하며, 구현 객채를 생성하는 클래스를 **구현 클래스**라 한다. 

```java
public class 구현 클래스 명 implements 인터페이스 명
{
	// 인터페이스에 선언된 추상 메소드이 실체 매소드 선언
}
```

##### RemoteControl.java (인터페이스)

```java
package me.ssonsh.java8to11.interfacetest;

public interface RemoteControl {
	int MAX_VOLUME = 100;
	int MIN_VOLUME = 0;
	
	void turnOn();
	void turnOff();
	void setVolum(int volume);
	
	default void setMute(boolean mute){
	
	}
}
```

Tv.java (RemoteControl.java 인터페이스를 구현한 구현 클래스)

```
package me.ssonsh.java8to11.interfacetest;

public class Tv implements RemoteControl{
	private int volume;
	
	@Override
	public void turnOn() {
		System.out.println("Tv를 켭니다.");
	}
	
	@Override
	public void turnoff() {
		System.out.println("Tv를 끕니다.");
	}
	
	@Override
	public void setVolume(int volume) {
		if(volume > RemoteControl.MAX_VOLUME){
			this.volume = RemoteControl.MAX_VOLUME;
		}else if(volume < RemoteControl.MIN_VOLUME){
			this.volume = RemoteControl.MIN_VOLUME;
         }else{
			this.volume = volume;
		}
    }
}
```



### 익명 구현 객체

구현 클래스를 만들어 사용하는 것이 일반적이다. 하지만, **일회성의 구현 ㄴ객체를 만들기 위해 ** 소스 파일을 만들고 클래스를 선언하는 것은 비효율적이다.

자바는 소스 파일을 만들지 않고 구현 객체를 만들 수 있는 방법을 제공하며 "익명 구현 객체"라고 한다.

```java
인터페이스 변수 = new 인터페이스() {
	// 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}
```

오류가 발생하지 않도록 인터페이스에 선언된 추상메소드를 실체 메소드로 선언해야한다. 

### 다중 인터페이스 구현 클래스

객체는 다수의 인터페이스 타입으로 사용할 수 있다.

인터페이스 A와 인터페이스 B가 객체의 매소드를 호출할 수 있으려면, 객체는 이들 두 인터페이스를 모두 구현해야 한다.

```java
public class 구현 클래스 implements 인터페이스A, 인터페이스B
{
	// 인터페이스 A의 추상 메소드 실체 매소드 선언
	// 인터페이스 B의 추상 매소드 실체 매소드 선언
}
```

다중 인터페이스를 구현할 경우

구현 클래스는 모든 인터페이스의 추상 매소드의 대해 실체 매소들들 작성해야 한다.

## 인터페이스 상속과 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법

### 인터페이스 상속

인터페이스의 상속 구조에서는

-> 서브 인터페이스는 수퍼 인터페이스의 메서드까지 모두 구현해야 한다.

> 인터페이스 레퍼런스는 인터페이스를 구현한 클래스의 인스턴스를 가리킬 수 있고, 해당 인터페이스에 선언된 매서드만 호출 할 수 있다.

#### 인터페이스 다중 상속

인터페이스는 클래스와 달리 다중 상속이 가능하다.

인터페이스의 매서드는 추상 매서드로 구현하기 전의 매서드이기 때문에 어떤 인터페이스의 매서드를 상속받아도 같기 때문이다.

> 상위 인터페이스 매서드 중에서 매서드 명과 파라미터 형식은 같지만 **리턴 타입이 다른 매서드**는 둘중, 어떤 것을 상속받느냐에 따라 규칙이 달라지기 때문에 다중 상속 불가능.

### 다중 인터페이스에서의 인터페이스 레퍼런스

다중 인터페이스를 통해 클래스는 여러개의 규칙을 적용할 수 있습니다. 

한 클래스로 여러 개의 인터페이스를 구현했다면, 각 인터페이스로 구분해서 객체를 사용할 수 있다.

구현체를 어떤 인터페이스 레퍼런스에 담느냐에 따라 사용할 때 따르는 규칙이 다르다.

## 인터페이스의 기본 메소드 (Default Method), 자바 8

#### 인터페이스에서의 기본 매소드란?

- 인터페이스에 매솟드 선언이 아니라 "구현체"를 제공하는 방법
- 해당 인터페이스를 구현한 클래스의 어떠한 영향없이 새로운 기능을 추가하는 방법.
- default method 는 해당 인터페이스를 구현한 구현체가 모르게 추가된 기능임으로 그만큼 리스크가 따른다.
  - 컴파일 에러는 발생하지 않지만, 특정한 구현체의 로직에 따라 런타임 에러가 발생할 수 있다.
  - 사용하게 된다면, 구현체가 잘못사용하지 않도록 반드시 문서화 중요.
- Object가 제공하는 긱능(equals, hashCode) 와 같은 기본 메소드는 제공할 수 없다.
  - 구현체가 재정의 하여 사용하는 것은 상관없음.
- 본인이 수정할 수 있는 인터페이스만 기본 메소드를 제공할 수 있다.
- 인터페이스를 상속받는 인터페이스에서 다시 추상 메소드로 변경 가능
- 인터페이스 구현체가 default method 를 재정의 할 수 있다.

## 인터페이스의 static 메소드, 자바 8

- 인터페이스를 구현한 모든 인스턴스, 해당 타입에 관련되어 있는 유틸리티, 헬퍼 메소드를 제공하고 싶다면, static method 로 제공할 수 있다.
- 인스턴스 없이 수행할 수 있는 작업을 정의할 수 있는 것이라 볼 수 있다.
- 형태

> static {리턴타입} {메소드명}({파라미터}){
>
> ​	// do something
>
> }

- ## (optional) 인터페이스의 private 메소드, 자바 9

java8 에서는 default method와 static methods를 추가했는데, java9 에서는 추가적으로 private method 와 private static method가 추가되었다.

- java 8의 default method 와 static method는 여전히 불편하다
- 단지 특정 기능을 처리하는 내부 method일 뿐인데도, 외부에 공개되는 public method로 만들어야 하기 때문이다.
- interface를 구현하는 다른 interface 혹은 class가 해당 method에 엑세스 하거나 상속할 수 있는 것을 원하지 않지만, 그렇게 될 수 있는 것이다.

java 9 에서는 위와 같은 사항으로 인해, `private method` 와 `private static method` 라는 새로운 기능을 제공함으로써  문제를 풀어간다.

> 코드의 중복을 피하고 interface에 대한 캡슐화를 유지할 수 있게 되었다.



---

>  링크 : https://www.notion.so/4b0cf3f6ff7549adb2951e27519fc0e6





>  백기선님의 도움으로 이렇게 공부할 수 있는 시간을 확보할 수 있는 기회를 만들기 위해 노력할 수 있어 행복합니다. 새해에도 항상 건강하시고 하는일 모두 잘 되시길 바랍니다.  
